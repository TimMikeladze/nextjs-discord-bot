import fs from 'node:fs';
import path from 'node:path';
import discord, {Events, GatewayIntentBits, Partials, User} from 'discord.js';
import './assert-env-vars';

import {FeatureFile, PendingAnswer} from './types';
import { isJsOrTsFile } from './utils';
import { slashCommands, contextMenuCommands } from './commands';
import Keyv from "keyv";

const INTRO_CHANNEL_ID = '766393115044216854';
const VERIFIED_ROLE = '930202099264938084';

if (!process.env.DISCORD_BOT_TOKEN) {
  throw new Error('No bot token found!');
}

const client = new discord.Client({
  intents: [
    GatewayIntentBits.Guilds,
    GatewayIntentBits.GuildMessages,
    GatewayIntentBits.GuildMessageReactions,
    GatewayIntentBits.MessageContent,
  ],
  partials: [Partials.Message, Partials.Channel, Partials.Reaction],
});

const features: FeatureFile[] = [];
const featureFiles = fs
  .readdirSync(path.resolve(__dirname, './features'))
  // Look for files as TS (dev) or JS (built files)
  .filter(isJsOrTsFile);

for (const featureFile of featureFiles) {
  // eslint-disable-next-line @typescript-eslint/no-var-requires
  const feature = require(`./features/${featureFile}`) as FeatureFile;
  features.push(feature);
}


let chatgpt: any;
let chatgptSessionInitialized = false;

const keyv = new Keyv(process.env.KEYV_URI);
const PENDING_ANSWERS_KEY = 'pendingAnswers';

client.on('ready',async () => {
  console.log(`Logged in as ${client.user?.tag}!`);
  features.forEach((f) => f.onStartup?.(client));
  if (process.env.OPENAI_EMAIL) {
    if (!chatgpt) {
      const { ChatGPTAPIBrowser, ChatGPTAPI } = await import('chatgpt');
      chatgpt = process.env.OPENAI_PASSWORD ? new ChatGPTAPIBrowser({
        email: process.env.OPENAI_EMAIL,
        password: process.env.OPENAI_PASSWORD,
      }) : new ChatGPTAPI({
        sessionToken: process.env.OPENAI_SESSION_TOKEN,
        clearanceToken: process.env.OPENAI_CLEARANCE_TOKEN,
        userAgent: process.env.OPENAI_USER_AGENT,
      });
    }
    if (!chatgptSessionInitialized) {
      await chatgpt?.initSession();
      chatgptSessionInitialized = true;
      console.log("ChatGPT session initialized");
    }
  }
});

client.on(Events.MessageReactionAdd, async (reaction, ) => {
  const message = reaction.message
  const channelId = message.channelId;

  if (channelId === process.env.HELP_FORUM_AUTO_ANSWER_CHANNEL_ID && chatgpt) {
    await reaction.fetch();

    if (reaction.emoji.name === process.env.HELP_FORUM_APPROVED_EMOJI_NAME || (reaction.count && reaction.count >= Number(process.env.HELP_FORUM_AUTO_ANSWER_MIN_APPROVALS))) {
      const pendingAnswers: PendingAnswer[] = await keyv.get(PENDING_ANSWERS_KEY) || [];

      const pendingAnswer = pendingAnswers.find((x: PendingAnswer) => x.messageId === message.id);

      const users = await reaction.users.fetch();

      const usernames = new Set<string>();

      users.forEach((user: User) => {
        if (user.bot) return;
        usernames.add(`<@${user.id}>`);
      })

      const formattedUsernames = Array.from(usernames).join(' ');

      if (pendingAnswer) {
        const channel = client.channels.cache.get(pendingAnswer.threadId);
        if (channel?.isThread()) {
          const response = `${pendingAnswer.response}

ðŸ¤–  This answer was generated by ChatGPT and approved by ${process.env.HELP_FORUM_SHOW_COMMUNITY_MEMBERS === "true" ? formattedUsernames : "our community members" }. If you have any questions, please ask them in this the thread.`;

          await channel.send(response)
          await keyv.set(PENDING_ANSWERS_KEY, pendingAnswers.filter((x: PendingAnswer) => x.messageId !== message.id));
        }
      }
    }
  }
})

client.on(Events.ThreadCreate, async (thread) => {
  const channelId = thread.parentId;
  if (channelId === process.env.HELP_FORUM_CHANNEL_ID && chatgpt) {
    // send a message to a different channel
    const channel = await client.channels.fetch(
      process.env.HELP_FORUM_AUTO_ANSWER_CHANNEL_ID
    );

    if (!channel) {
      console.error('Could not find auto answer channel');
    }

    if (channel?.isTextBased()) {
      const message = await thread.fetchStarterMessage();
      const question = [thread.name, message?.content].filter(Boolean).join('\n')
      try {
        const {response} = await chatgpt.sendMessage(question);
        const newMessage = await channel.send(`
${message?.url}
${message?.content}

--------------------

${response}`)
        const pendingAnswers = await keyv.get(PENDING_ANSWERS_KEY) || [];
        await keyv.set(PENDING_ANSWERS_KEY, [...pendingAnswers, {
          threadId: thread.id,
          messageId: newMessage.id,
          response,
        }]);
      } catch (e) {
        console.error(e)
      }
    }
  }
})

client.on(Events.InteractionCreate, async (interaction) => {
  if (interaction.isChatInputCommand()) {
    slashCommands
      .find((c) => c.data.name === interaction.commandName)
      ?.execute(interaction);
  }

  if (interaction.isMessageContextMenuCommand()) {
    contextMenuCommands
      .find((c) => c.data.name === interaction.commandName)
      ?.execute(interaction);
  }
});

client.on('messageCreate', (message) => {
  if (message.author.bot) return;

  // if user types into the intros channel, give them the verified role
  if (message.channel.id == INTRO_CHANNEL_ID) {
    message.member?.roles
      .add(VERIFIED_ROLE)
      .catch((err) => console.log(err.message, 'Verify'));
  }

  features.forEach((f) => f.onMessage?.(client, message));
});

client.on('messageReactionAdd', async (reaction, user) => {
  if (user.partial) {
    try {
      await user.fetch();
    } catch (error) {
      console.log('Error while trying to fetch an user', error);
    }
  }

  if (reaction.message.partial) {
    try {
      await reaction.message.fetch();
    } catch (error) {
      console.log('Error while trying to fetch a reaction message', error);
    }
  }

  if (reaction.partial) {
    try {
      const fetchedReaction = await reaction.fetch();
      features.forEach((f) =>
        f.onReactionAdd?.(client, fetchedReaction, user as User)
      );
    } catch (error) {
      console.log('Error while trying to fetch a reaction', error);
    }
  } else {
    features.forEach((f) => f.onReactionAdd?.(client, reaction, user as User));
  }
});

client.on('messageReactionRemove', async (reaction, user) => {
  if (user.partial) {
    try {
      await user.fetch();
    } catch (error) {
      console.log('Error while trying to fetch an user', error);
    }
  }

  if (reaction.message.partial) {
    try {
      await reaction.message.fetch();
    } catch (error) {
      console.log('Error while trying to fetch a reaction message', error);
    }
  }

  if (reaction.partial) {
    try {
      const fetchedReaction = await reaction.fetch();
      features.forEach((f) =>
        f.onReactionRemove?.(client, fetchedReaction, user as User)
      );
    } catch (error) {
      console.log('Error while trying to fetch a reaction', error);
    }
  } else {
    features.forEach((f) =>
      f.onReactionRemove?.(client, reaction, user as User)
    );
  }
});

// Wake up ðŸ¤–
client.login(process.env.DISCORD_BOT_TOKEN);
